const express = require('express');
const router = express.Router();
const AWS = require('aws-sdk');
const moment = require('moment');
const logger = require('./logger');

// Authorization middleware
const authorize = (req, res, next) => {
  // Check for authorization header
  const authHeader = req.headers.authorization;
  
  if (!authHeader) {
    return res.status(401).json({ 
      error: 'Authorization required',
      code: 'UNAUTHORIZED'
    });
  }
  
  // In a real application, you would validate the token/credentials here
  // For now, we'll just check if the header exists
  // TODO: Implement proper token validation
  
  next();
};

// Configure AWS
const docClient = new AWS.DynamoDB.DocumentClient();

/**
 * Get productivity trends over time
 * Analyzes productivity metrics over specified time periods
 */
router.get('/productivity', authorize, async (req, res) => {
  try {
    const { userId, startDate, endDate, interval = 'day' } = req.query;
    
    // Validate date parameters
    if (!startDate || !endDate) {
      return res.status(400).json({ 
        error: 'Start date and end date are required',
        code: 'INVALID_PARAMETERS'
      });
    }
    
    // Validate interval parameter
    const validIntervals = ['day', 'week', 'month'];
    if (!validIntervals.includes(interval)) {
      return res.status(400).json({ 
        error: 'Invalid interval. Must be one of: day, week, month',
        code: 'INVALID_PARAMETERS'
      });
    }
    
    // Set up query parameters
    const params = {
      TableName: process.env.DYNAMODB_USER_ACTIVITY_LOG_TABLE,
      IndexName: 'DateIndex', // Assuming there's a GSI on the Date field
      KeyConditionExpression: '#date BETWEEN :startDate AND :endDate',
      ExpressionAttributeNames: {
        '#date': 'Date'
      },
      ExpressionAttributeValues: {
        ':startDate': startDate,
        ':endDate': endDate
      }
    };
    
    // Add user filter if provided
    if (userId) {
      params.FilterExpression = 'UserId = :userId';
      params.ExpressionAttributeValues[':userId'] = userId;
    }
    
    // Use query instead of scan for better performance
    let activityData;
    try {
      activityData = await docClient.query(params).promise();
    } catch (error) {
      // If DateIndex doesn't exist, fall back to scan with filter
      if (error.code === 'ValidationException' && error.message.includes('IndexName')) {
        delete params.IndexName;
        delete params.KeyConditionExpression;
        
        params.FilterExpression = params.FilterExpression 
          ? `#date BETWEEN :startDate AND :endDate AND ${params.FilterExpression}`
          : '#date BETWEEN :startDate AND :endDate';
          
        activityData = await docClient.scan(params).promise();
        
        // Log warning about inefficient operation
        logger.warn('Using scan operation instead of query. Consider creating a GSI on Date field for better performance.');
      } else {
        throw error;
      }
    }
    
    // Group data by time interval
    const groupedData = groupDataByTimeInterval(activityData.Items, interval);
    
    // Calculate trends
    const trends = calculateProductivityTrends(groupedData);
    
    res.json(trends);
  } catch (error) {
    logger.error('Error fetching productivity trends:', { error: error.message, stack: error.stack });
    res.status(500).json({ 
      error: 'An error occurred while fetching productivity trends',
      code: 'INTERNAL_SERVER_ERROR'
    });
  }
});